# -*- shell-script -*-
#

# Source function library.

INIT_FUNCTIONS="${INIT_LIBDIR}/init-functions-x-generic /etc/rc.d/init.d/functions"

for init_functions in $INIT_FUNCTIONS; do
    if [ -r "${init_functions}" ]; then
	. "${init_functions}"
    else
	[ -z "$DEBUG" ] || printf "${INIT_FUNCTIONS}: file not found\n" >&2
	false
    fi
done


x_log_success_msg()
{
    success "$*"
    echo
}


x_log_failure_msg()
{
    failure "$*"
    echo
}


x_log_warning_msg()
{
    warning "$*"
    echo
}


x_status()
{
    local opt=
    local pidfile=
    local daemon=
    local name=
    local pid=
    local pid_exe=
    local rc=0

    OPTIND=1
    while getopts 'p:n:' opt; do
        case "$opt" in
            (n) name="$OPTARG";;
            (p) pidfile="$OPTARG";;
        esac
    done

    shift $(($OPTIND-1))
    daemon="$(readlink --canonicalize "$1")"
    shift

    if [ -z "$name" ]; then
	name="${daemon##*/}"
    fi

    if [ -z "$pidfile" ]; then
	pidfile="/var/run/$name.pid"
    fi

    status "$daemon" || rc=$?

    return $rc
}


x_start()
{
    # FIXME - pidfile doesn't get used - not available on older RHEL 4.x
    local opt=
    local pidfile=
    local daemon=
    local name=
    local create=
    local rc=0

    OPTIND=1
    while getopts 'cn:p:' opt; do
        case "$opt" in
	    (c) create=1;;
            (n) name="$OPTARG";;
            (p) pidfile="$OPTARG";;
        esac
    done

    shift $(($OPTIND-1))
    daemon="$(readlink --canonicalize "$1")"
    shift

    if [ -z "$name" ]; then
	name="${daemon##*/}"
    fi

    if [ -z "$pidfile" ]; then
	pidfile="/var/run/${daemon##*/}.pid"
    fi

    if [ "--" = "${1:-}" ]; then
	shift
    fi

    if x_status -p "$pidfile" "$daemon" >/dev/null; then
	# already running
	return 0
    fi

    local orig_pids="$(x_generic_pidof "$daemon")"

    daemon "$daemon" "$@" || rc=$?

    if [ -n "$create" ]; then
        # Try to avoid a race condition between starting, forking and capturing the PID
	sleep 2

	local new_pids="$(x_generic_pidof "$daemon")"
	local pid="$(x_generic_new_pids "$orig_pids" "$new_pids")"
	printf "$pid\n" >"$pidfile"
    fi

    return $rc
}


x_stop()
{
    local opt=
    local pidfile=
    local daemon=
    local name=
    local delete=
    local forcekill=
    local pid=
    local signal="15"
    local timeout=5
    local rc=0

    OPTIND=1
    while getopts 'dfn:p:s:t:' opt; do
        case "$opt" in
	    (d) delete=1;;
	    (f) forcekill=1;;
            (n) name="$OPTARG";;
            (p) pidfile="$OPTARG";;
	    (s) signal="$OPTARG";;
	    (t) timeout="$OPTARG";;
        esac
    done

    shift $(($OPTIND-1))
    daemon="$(readlink --canonicalize "$1")"
    shift

    if [ -z "$name" ]; then
	name="${daemon##*/}"
    fi

    if [ -z "$pidfile" ]; then
	pidfile="/var/run/${daemon##*/}.pid"
    fi

    killproc "$daemon" "$signal" || rc=$?

    if [ 0 -eq "$rc" \
	-a -n "$delete" ]; then
	rm -f "$pidfile"
    fi

    return $rc
}


true
